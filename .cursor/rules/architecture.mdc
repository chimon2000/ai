---
description: "Code organization"
alwaysApply: false
---

#### Code Organization

##### Choosing the Right Structure

**Small** (< 10 screens): Flat structure - models/, services/, screens/, widgets/
**Medium** (10-30 screens): Feature-based - ui/[feature]/ with stores
**Large** (30+ screens): MVU pattern - app/, data/, domain/, ui/ with state/

##### Decision Criteria for Migration

**Migrate Small → Medium when:**
- Project has 10+ screens or 3+ features
- Multiple screens share business logic
- Need to organize related screens together
- Team size growing (2+ developers)
- Complexity of state management increasing

**Migrate Medium → Large when:**
- Project has 30+ screens or 5+ features
- Complex business logic across multiple layers
- Need clear separation between data and presentation
- Team size 3+ developers
- Reusable domain logic across features
- API/repository layer becoming complex

**Signs you're ready to migrate:**
- Current structure feels disorganized
- Hard to find related files
- Duplicate code across features
- Difficult to test business logic
- New team members struggle with structure

**Signs you're not ready to migrate:**
- Project still < 10 screens
- Simple, linear data flow
- Single developer or very small team
- Prototype or MVP phase
- Frequent structural changes expected

##### Small Project Structure

```
lib/
├── main.dart
├── models/              # Data models
├── services/            # Business logic & API calls
├── screens/             # All screens
└── widgets/             # Shared widgets
```

**When to use:** < 20 files, simple data flow, prototypes

##### Medium Project Structure

```
lib/
├── main.dart
├── models/              # Shared data models
├── services/            # Shared services
├── ui/                  # UI layer with features
│   ├── auth/           # Feature: Authentication
│   ├── home/           # Feature: Home
│   └── widgets/        # Shared UI components
└── utils/               # Shared utilities
```

**When to use:** 10-30 screens, multiple features, growing team

##### MVU (Model-View-Update) Pattern

**Model**: Immutable state (Equatable) - pure data, no logic
**View**: Pure UI (screen widgets) - renders based on state
**Update**: Store (Notifier) - manages state transitions and side effects

**Benefits:** Clear separation, predictable state, easy testing, type-safe, unidirectional flow

**When to use:** Large projects, complex state, multiple state variations, testing priority

**Medium vs Large:**
- **Medium**: Store at feature root - `class AuthStore extends AsyncNotifier<User?>`
- **Large**: Store in state/ subdirectory - `class LoginStore extends Notifier<LoginState>` (with separate state file)

##### Large Project Structure (MVU Pattern)

```
lib/
├── main.dart
├── app/                    # App-level configuration
├── core/                   # Core utilities & constants
├── data/                   # Data layer
├── domain/                 # Business logic & entities
└── ui/                     # Presentation layer
    ├── auth/              # Feature: Authentication
    ├── home/              # Feature: Home
    └── widgets/           # Reusable non-feature components
```

**When to use:** 30+ screens, complex business logic, large team, clean architecture

#### Testing Considerations

**Small**: Test screens/services directly, minimal mocking, integration tests
**Medium**: Test stores with mocked services, widget tests with mocked providers
**Large (MVU)**: Unit test state (copyWith, equality), unit test stores (mock repos), widget test screens (mock stores), integration test flows

#### Migration Paths

**Small → Medium (when criteria met):**

1. Create `ui/` directory for all UI components
2. Group related screens into feature folders under `ui/`
3. Move screen-specific widgets into feature `widgets/` folders
4. Add stores for business logic
5. Keep shared models and services at root level
6. Move shared widgets to `ui/widgets/`
7. Update imports and test all features work

```bash
# Before (Small)
lib/screens/login_screen.dart
lib/screens/home_screen.dart
lib/widgets/login_form.dart
lib/widgets/custom_button.dart

# After (Medium)
lib/ui/auth/login_screen.dart
lib/ui/auth/widgets/login_form.dart
lib/ui/auth/auth_store.dart
lib/ui/home/home_screen.dart
lib/ui/home/home_store.dart
lib/ui/widgets/buttons/custom_button.dart
```

**Medium → Large (when criteria met):**

1. Create `app/`, `data/`, `domain/` directories (keep existing `ui/`)
2. Reorganize features within `ui/` to add sub-feature structure
3. Refactor stores to MVU pattern:
   - Create `state/` directory in each feature
   - Split store into `[feature]_state.dart` (Equatable) and `[feature]_store.dart` (Notifier)
   - Add `[feature]_event.dart` if using event-driven updates
4. Extract data models to `data/models/`
5. Create repositories in `data/repositories/`
6. Add domain entities in `domain/entities/`
7. Move app config to `app/`
8. Extract shared utilities to `core/`
9. Shared widgets already in `ui/widgets/` (no change needed)
10. Migrate incrementally - one feature at a time

```bash
# Before (Medium)
lib/ui/auth/login_screen.dart
lib/ui/auth/auth_store.dart
lib/ui/auth/widgets/login_form.dart
lib/models/user.dart
lib/services/api_service.dart

# After (Large with MVU)
lib/ui/auth/login/login_screen.dart
lib/ui/auth/login/state/login_state.dart
lib/ui/auth/login/state/login_store.dart
lib/ui/auth/login/state/login_event.dart
lib/ui/auth/login/widgets/login_form.dart
lib/ui/widgets/buttons/primary_button.dart
lib/data/models/user.dart
lib/domain/entities/user_entity.dart
lib/data/repositories/user_repository.dart
lib/data/services/api_service.dart
```

#### General Principles

- Follow existing project structure - don't mix structures
- Group related files together
- Consistent naming: `*_screen.dart`, `*_store.dart`, `*_widget.dart`
- One widget per file (except small private helpers)
- Use `index.dart` for barrel exports
- Features should not import from other features

