---
alwaysApply: true
---
#### Testing Strategy

##### Test-Driven Development (TDD)

- **Write tests first** for any new functionality
- **Follow the Red-Green-Refactor (TDD) cycle** when writing code:
  1. **RED**: Write a failing test that describes the desired behavior
  2. **GREEN**: Write the minimal code to make the test pass
  3. **REFACTOR**: Improve the code while keeping tests green
- **Run tests after each step** to ensure they pass/fail as expected
- **Exception**: Spike/exploration work may skip TDD temporarily, but must be refactored with tests before merging

##### Testing Trophy Model

Follow the Testing Trophy for effective test coverage:

```
       ___
      /   \
     /  E2E \        30% - End-to-End Tests
    /_______\
   /         \
  / Integration \    50% - Integration Tests (PRIMARY FOCUS)
 /_______________\
/                 \
|   Unit Tests    |  20% - Unit Tests
|_________________|
|_Static_Analysis_| Base - Linting, Type Checking, Compiler
```

**Static Analysis (Foundation):**
- Linting with `flutter analyze`
- Type checking with strict mode
- Compiler errors caught before runtime
- Custom lint rules (riverpod_lint, custom_lint)

**Unit Tests (~20%):**
- Pure functions, utilities, models
- Complex business logic in isolation
- Data transformations and calculations
- Edge cases and boundary conditions

**Integration Tests (~50% - PRIMARY FOCUS):**
- Feature flows with stores and real dependencies
- User interactions and state changes together
- Stores with real repositories (mock only external APIs)
- Widget + store + service integration
- Data flows through the app

**E2E Tests (~30%):**
- Critical user journeys end-to-end
- Complete flows: login → dashboard → action → logout
- Real backend (or realistic mocks)
- Happy paths and critical business flows

**Why Integration Tests are Primary:**
- ✅ Test how components work together (closer to real usage)
- ✅ Catch more bugs than isolated unit tests
- ✅ Resilient to refactoring (test behavior, not implementation)
- ✅ Balance between speed and confidence

##### What to Test

**Integration Tests (Primary):**
- User behavior and feature flows
- Store + Repository + Service integration
- State management with real dependencies (mock only external APIs)
- Navigation flows and screen transitions
- Form validation with submission
- Error handling across layers
- Widget + Store integration

**Unit Tests (Secondary):**
- Complex business logic (calculations, algorithms)
- Pure functions (utilities, validators, formatters)
- Data models (serialization, equality, copyWith)
- Edge cases (boundary conditions, null handling)

**E2E Tests (Tertiary):**
- Critical user journeys (login, checkout, payment)
- Happy paths and common user flows
- Cross-feature flows
- Regression prevention

**Don't test:**
- ❌ Third-party packages
- ❌ Flutter framework widgets
- ❌ Generated code (*.g.dart, *.freezed.dart)
- ❌ Simple getters/setters without logic
- ❌ UI styling (colors, fonts)
- ❌ Implementation details

#### When to Apply Testing Trophy

**Use Testing Trophy (50% integration focus) for:**
- Feature-complete screens with stores and services
- Complex user workflows and state management
- Production apps with multiple features
- Teams prioritizing confidence over speed

**Focus on Unit Tests (80%+ unit focus) for:**
- Utility libraries and pure functions
- Complex algorithms or business logic
- Shared components used across features
- Performance-critical code

**Use E2E Tests (30%+ E2E focus) for:**
- Critical user journeys (authentication, payments)
- Multi-screen workflows
- Regression prevention for high-value features

#### Unit Testing

##### Store Testing

**Best Practices:**
- Test all public methods of stores
- Use `mocktail` for mocking external services
- Register fallback values with `registerFallbackValue()` for complex types
- Test Result<T> return types with `.isSuccess()` and `.isError()`
- Test error handling paths
- Verify analytics calls are made correctly
- Test navigation calls with mock router

**Example:**

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:mocktail/mocktail.dart';

class MockUserService extends Mock implements UserService {}

void main() {
  late MockUserService mockUserService;
  late ProviderContainer container;

  setUp(() {
    mockUserService = MockUserService();
    container = ProviderContainer(
      overrides: [
        userServiceProvider.overrideWithValue(mockUserService),
      ],
    );
  });

  tearDown(() {
    container.dispose();
  });

  group('UserStore', () {
    test('should load user successfully', () async {
      // Arrange
      final user = User(id: '1', name: 'John');
      when(() => mockUserService.getUser('1'))
          .thenAnswer((_) async => Success(user));

      // Act
      final store = container.read(UserStore.provider.notifier);
      final result = await store.loadUser('1');

      // Assert
      expect(result.isSuccess(), true);
      expect(result.getOrNull(), user);
      verify(() => mockUserService.getUser('1')).called(1);
    });

    test('should handle error when loading user fails', () async {
      // Arrange
      when(() => mockUserService.getUser('1'))
          .thenAnswer((_) async => Failure(Exception('Network error')));

      // Act
      final store = container.read(UserStore.provider.notifier);
      final result = await store.loadUser('1');

      // Assert
      expect(result.isError(), true);
      expect(result.exceptionOrNull()?.toString(), contains('Network error'));
    });
  });
}
```

